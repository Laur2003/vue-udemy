<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VueJs Cheat Sheet</title>

    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600" rel="stylesheet">
    <style>
        body {
          background-color: antiquewhite;
          padding: 20px;
        }
        h1 {
          font-size: 30px;
          font-weight: 700;
          font-family: "Poppins", serif;
        }

        h2 {
          font-size: 20px;
          font-weight: 500;
          font-family: "Poppins", serif;
        }

        p,li {
          font-size: 16px;
          font-weight: 400;
          font-family: "Poppins", serif;
        }

        .code {
          font-family: 'Courier New', Courier, monospace;
          color: #59ae81;
          background-color: rgb(54, 54, 54);
          display: inline-block;
          padding: 6px 20px 20px;
          white-space: pre;
          width: auto;
        }

        .note {
          font-style: italic;
        }

        img {
          max-width: 700px;
        }
    </style>
</head>
<body>
    <h1>Different ways of using vue</h1>
    <ol>
        <li>Widget - approach on a MPA (Multi page application) to control certain parts of the pages which are rendered on and served by a backend server.</li>
        <li>SPA (Single Page Application) - Server only sends one HTML page, thereafter, Vue takes over and controls the UI.</li>
    </ol>

    <p>{{ variable }} - is only available between the tags (not as an attribute)</p>
    <h2>example:</h2>
    <code class="code"></code>
    
    <br>
    <h1>v-bind</h1>

    <p>v-bind:attributeName="variableName" - for attributes</p>
    <p>instead of v-bind we can use : as a shortcut</p>
    <h2>example:</h2>
    <code class="code"></code>


    <p>we can also use just :href="link" as a shortcut<p>

    <p>inside {{ }} we can execute simple js code such as {{ 1 + 1 }}, {{ functionName() }} etc (not really used though)</p>
    <br>
    <h1>v-html</h1>
    <p>v-html="variableName" can be used if the variable stores an html structure</p>
    
    <h2>examples:</h2>
    <code class="code"></code>
    
    <p>however, this is not the best thing to do as it may create security issues</p>

    <h1>Events: (v-on)</h1>
    <p>v-on:eventName="action"</p>
    <p>instead of v-on we can use @ as a shortcut</p>
    <h2>example:</h2>
    <code class="code"></code>

    <p>these functions can also take a parameter</p>
    <h2>example:</h2>
    <code class="code"></code>

    <p>we can also do some logic inside html but it's not the best practice</p>
    <h2>example:</h2>
    <code class="code"></code>


    <p>change a variable on an event</p>
    <h2>example:</h2>
    <code class="code"></code>

    <p class="note">Note: "event" is sent by default by the browser</p>

    <p>If we need to send another variable to the function, we need to include $event in the parameters list</p>
    <h2>example:</h2>
    <code class="code"></code>

    <h1>Event modifiers</h1>
    <p>Instead of using the traditional event.preventDefault(), Vue offers some modifiers of its own (.prevent)</p>
    <code class="code"></code>

    <ol>
        <li>
          <strong>.stop</strong>
          <ul>
            <li><strong>Description:</strong> Prevents further propagation of the current event.</li>
          </ul>
        </li>
        <li>
          <strong>.prevent</strong>
          <ul>
            <li><strong>Description:</strong> Prevents the default action of the event.</li>
          </ul>
        </li>
        <li>
          <strong>.capture</strong>
          <ul>
            <li><strong>Description:</strong> Makes the event listener run in the capture phase.</li>
          </ul>
        </li>
        <li>
          <strong>.self</strong>
          <ul>
            <li><strong>Description:</strong> Ensures the event is triggered only if the event target is the element itself.</li>
          </ul>
        </li>
        <li>
          <strong>.once</strong>
          <ul>
            <li><strong>Description:</strong> Ensures the event listener is invoked at most once.</li>
          </ul>
        </li>
        <li>
          <strong>.passive</strong>
          <ul>
            <li><strong>Description:</strong> Indicates that the event listener will never call <code>preventDefault()</code>. Useful for performance optimization in scroll events.</li>
          </ul>
        </li>
        <li>
          <strong>.native</strong> (Vue 2 only)
          <ul>
            <li><strong>Description:</strong> Allows listening to native DOM events on child components.</li>
          </ul>
        </li>
        <li>
          <strong>.exact</strong>
          <ul>
            <li><strong>Description:</strong> Ensures the event is triggered only if the exact modifier keys are pressed.</li>
          </ul>
        </li>
        <li>
          <strong>Modifier Key Combinations</strong>
          <ul>
            <li><strong>Description:</strong> Requires specific keys to be pressed (e.g., <code>.ctrl</code>, <code>.alt</code>, <code>.shift</code>, <code>.meta</code>).</li>
          </ul>
        </li>
        <li>
          <strong>Key Event Modifiers</strong>
          <ul>
            <li><strong>Description:</strong> Used to listen for specific key presses (e.g., <code>.enter</code>, <code>.tab</code>, <code>.delete</code>, <code>.esc</code>, etc.).</li>
          </ul>
        </li>
        <li>
          <strong>Chaining Modifiers</strong>
          <ul>
            <li><strong>Description:</strong> Modifiers can be chained for more precise control.</li>
          </ul>
        </li>
    </ol>

    <h2>example:</h2>
    <code class="code"></code>

    <h2>v-model or the two-way binding</h2>
    <p>instead of using the v-bind:value in pair with the v-on:click</p>
    <code class="code"></code>
    <p>we can just use v-model which does the same as the code above</p>
    <code class="code"></code>
    
    

    <h1>Computed properties</h1>
    <p>If we call a method to display a variable like this &lt;p&gt;{{ updatedName() }}&lt;/p&gt;, vue will call this method everytime there are any changes on the page because it doesn't know the dependencies of this method.
    This is why we use computed methods for displaying some changed variables since these will be executed only when their dependencies(variables) are changed.
    </p>

    <h2>example: (@keyup is just to make sure we display the updated name only when confirmed. Not really part of the example here)</h2>

    <code class="code"></code>

    <h1>Watchers</h1>
    <p>watch methods are used to change something or perform an action when a variable's value has changed. This is useful for http requests, alerts etc. A watch method is named as the variable it's supposed to watch after</p>

    <h2>example:</h2>
    <code class="code"></code>

    <h1>Methods vs Computed vs Watch</h1>
    <img src="./images/image1.png" alt="">

    <h1>Conditionally adding classes to elements</h1>
    <p>To add a class to an element we will use :class binding</p>
    <h2>example:</h2>
    <code class="code"></code>

    <p>we can also use computed methods to change the classes if the logic is a bit more complicated or if we have more classes to add/have</p>
    <h2>example:</h2>
    <code class="code"></code>

    <p>there is also the possibility to add classes using the array syntax. We can combine conditional and static classes in such arrays</p>
    <h2>example:</h2>
    <code class="code"></code>


    <h1>Conditional rendering/displaying</h1>
    <h2>v-if, v-else-if, v-else</h2>
    <p>to render content conditionally, we use v-if, v-else-if, v-else. This RENDERS the content which means if the condition is not true for any of these operators, the DOM will not populate with the respective content</p>

    <h2>example:</h2>
    <code class="code"></code>

    <h2>v-show</h2>
    <p>to render a piece of content in the DOM but just to hide it if needed, we can use v-show. Generally it's better to use conditional rendering instead of conditional hiding due to security reasons. However, if an element's visibility is being switched a lot and it's not impacting the security of the page, we will use v-show because of performance (rendering the same element multiple time is not the most optimal way to do thintgs)</p>


    <h1>Rendering lists of data</h1>
    <p>to render lists/arrays, we use v-for</p>
    <h2>example:</h2>
    <code class="code"></code>
    <p class="note">Note: if we have an unique ID available, it's always a good idea to also include :key="id"</p>

    <p>we can also use indexes for the loop</p>
    <h2>example:</h2>
    <code class="code"></code>

    <p>we can also loop through objects and display the key and the index</p>
    <h2>example:</h2>
    <code class="code"></code>

    <p>to remove an item from a list we can use .splice()</p>
    <h2>example:</h2>
    <code class="code"></code>

    <h1>Vue: Behind the Scenes</h1>
    <h2>ref</h2>
    <p>instead of saving the input value on every keystroke, we can use a ref</p>
    <h2>example - without ref:</h2>
    <code class="code"></code>

    <h2>example - with ref</h2>
    <code class="code"></code>


    <h2>Vue Instance Lifecycle</h2>
    <img src="./images/image2.png" alt="">
</body>
</html>



<script>
    const codes = [
`
<p>{{ message }}</p>
`,
`
<a v-bind:href="link">about Vue</a>
`,
`
<p v-html="outputGoal()"></p>
<p v-html="messageB"></p>
`,
`
<button v-on:click="add()">Add</button>
`,
`
<button v-on:click="add(5)">Add</button&gt>

methods: {
  add(num) {
    this.counter+=num;
  }
}`,
`
<button v-on:click="counter++">Add</button>
`,
`
<input type="text" v-on:input="changeName">

<p>Your Name: {{ name }}</p>

changeName(event) {
  this.name = event.target.value
}
`,
`
<input type="text" v-on:input="changeName($event,Racovet)">

<p>Your Name: {{ name }}</p>

changeName(event, lastName) {
  this.name = event.target.value + " " + lastName
}
`,
`
<form v-on:submit.prevent="submitForm">
  <input type="text">
  <button>Sign Up</button>
</form>


submitForm() {
  alert('Submitted');
}
`,
`
<input type="text" v-on:input="changeName($event, 'Racovet')" v-on:keyup.enter="confirmInput()">

confirmInput() {
  this.confirmedName = this.name;
},
`,
`
<input type="text" v-bind:value="name" v-on:input="setName">
<p>Your Name: {{ name }}</p>

setName(event) {
    this.name = event.target.value;
},
`,
`
<input type="text" v-model="name">
<p>Your Name: {{ name }}</p>
`,
`
<input type="text" v-model="name" @keyup.enter="confirmName">
<p>Your Name: {{ changedName }}</p>

computed: {
  changedName() {
    if (this.confirmedName != "")
    return this.confirmedName + " " + "Racovet";
    else return "";
  }
},
methods: {
  ...
  confirmName() {
    this.confirmedName = this.name;
  }
}
`,
`
watch: {
  counter(value) {
    if (value > 50) {
      this.counter = 0;
      window.alert("The counter has been set to 0");
    }
  }
},
`,
`
<div class="demo" :class="{active: boxSelected}" @click="clickOnBox"></div>

data() {
  return {
    boxSelected: false
  }
},
methods: {
  clickOnBox() {
    this.boxSelected = !this.boxSelected;
  }
}
`,
`
<div class="demo" :class="boxClasses" @click="clickOnBox"></div>

data() {
  return {
    boxSelected: false
  }
},
methods: {
  clickOnBox() {
    this.boxSelected = !this.boxSelected;
  }
},
computed: {
  boxClasses() {
    return { active: this.boxSelected }
  }
},
`,
`
<div :class="['demo', boxClasses]" @click="clickOnBox"></div>
`,
`
<p v-if="goals.length == 0">No goals have been added yet</p>
<ul v-else>
  <li>Goals</li>
</ul>

data() {
  return { 
    goals: []
  };
},
`,
`
<ul>
  <li v-for="goal in goals">{{ goal }}</li>
</ul>

data() {
  return { 
    goals: ['goal1', 'goal2']
  };
},
`,
`
<ul>
  <li v-for="(goal, index) in goals">{{ goal }}{{ index }}</li>
</ul>

data() {
  return { 
    goals: ['goal1', 'goal2']
  };
},
`,
`
<ul v-else>
  <li v-for="(goal, key, index) in goalsObject">{{ key }}-{{ goal }}-{{ index }}</li>
</ul>

data() {
  return { 
    goalsObject: {
      name: "TestGoal",
      importance: "High"
    }
  };
},
`,
`
<li
  v-for="(goal, index) in goals"
  @click="removeItem(index)">
  {{ goal }}{{ index }}
</li>

removeItem(index) {
  this.goals.splice(index, 1);
}
`,
`
<input type="text" @input="saveInput">
<button @click="setText">Set Text</button>

data() {
  return {
    currentUserInput: '',
    message: 'Vue is great!',
  };
},
methods: {
  saveInput(event) {
    this.currentUserInput = event.target.value;
  },
  setText() {
    this.message = this.currentUserInput;
  },
},
`,
`
<input type="text" ref="userInput">
<button @click="setText">Set Text</button>

data() {
  return {
    message: 'Vue is great!'
  };
},
methods: {
  setText() {
    this.message = this.$refs.userInput.value;
  },
},
`
]
    const codeElements = document.querySelectorAll(".code");

    codeElements.forEach((element, index) => {
        element.innerText = codes[index];
    });
</script>