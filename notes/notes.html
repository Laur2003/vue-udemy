<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VueJs Cheat Sheet</title>

  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-html.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>

  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      document.querySelectorAll('pre code').forEach((block) => {
        hljs.highlightElement(block);
      });
  });
</script>
  <style>
    body {
      background-color: #121212;
      color: #e0e0e0;
      padding: 40px;
    }
  
    h1 {
      font-size: 30px;
      font-weight: 700;
      font-family: "Poppins", serif;
      color: #ffffff;
    }
  
    h2 {
      font-size: 20px;
      font-weight: 500;
      font-family: "Poppins", serif;
      color: #ffffff;
    }
  
    p, li {
      font-size: 16px;
      font-weight: 400;
      font-family: "Poppins", serif;
      color: #e0e0e0;
    }

    img {
      max-width: 800px;
    }
  
    pre {
      background-color: #1e1e1e;
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #333;
      overflow-x: auto;
      padding: 0 10px !important;
      margin: 0;
      display: block;
    }
  
    code {
      font-family: 'Courier New', Courier, monospace;
      font-size: 14px;
      color: #dcdcaa !important;
      white-space: pre-wrap;
      text-shadow: none;
      padding: 0 !important;
      margin: 0;
      display: block;
      text-align: left;
      margin-top: 6px;
      margin-bottom: -12px;
    }
  
    .language-html {
      color: white !important;
      background-color: #1e1e1e !important;
      text-shadow: none !important;
    }

    .language-html .hljs-name {
      color: #4c9adb;
    }
    .language-html .hljs-attr {
      color: #9cd2ff;
    }
    .language-html .hljs-string {
      color: #fffeda;
    }
    .language-html .hljs-tag {
      color: #e1e1e1aa;
    }
  


    .language-javascript {
      color: #dcdcaa;
      background-color: #1e1e1e !important;
      text-shadow: none !important;
    }
    .language-javascript .hljs-attr { 
      color: #fa72ff;
    }
    .language-javascript .hljs-title { 
      color: #4db14d;
    }
    .language-javascript .hljs-params { 
      color: #9cd2ff;
    }
    .language-javascript .hljs-variable { 
      color: #4c9adb;
    }
    .language-javascript .hljs-property { 
      color: #9cd2ff;
    }
    .language-javascript .hljs-number { 
      color: #4c9adb;
    }
    .language-javascript .hljs-string { 
      color: #4c9adb;
    }

    
  </style>
</head>
<body>
    <h1>Different ways of using vue</h1>
    <ol>
      <li>Widget - approach on a MPA (Multi page application) to control certain parts of the pages which are rendered on and served by a backend server.</li>
      <li>SPA (Single Page Application) - Server only sends one HTML page, thereafter, Vue takes over and controls the UI.</li>
    </ol>

    <p>{{ variable }} - is only available between the tags (not as an attribute)</p>
    <h2>example:</h2>
    <pre>
    <code class="language-html">  &lt;p&gt;{{ message }}&lt;/p&gt;</code>
    </pre>
    
    <br>
    <h1>v-bind</h1>

    <p>v-bind:attributeName="variableName" - for attributes</p>
    <p>instead of v-bind we can use : as a shortcut</p>
    <h2>example:</h2>
    <pre>
    <code class="language-html">  &lt;a v-bind:href="link"&gt;about Vue&lt;/a&gt;</code>
    </pre>


    <p>we can also use just :href="link" as a shortcut<p>

    <p>inside {{ }} we can execute simple js code such as {{ 1 + 1 }}, {{ functionName() }} etc (not really used though)</p>
    <br>
    <h1>v-html</h1>
    <p>v-html="variableName" can be used if the variable stores an html structure</p>
    
    <h2>examples:</h2>
    
    <pre><code class="language-html">
  &lt;p v-html="outputGoal()"&gt;&lt;/p&gt;
  &lt;p v-html="messageB"&gt;&lt;/p&gt;</code>
    </pre>

    
    <p>however, this is not the best thing to do as it may create security issues</p>

    <h1>Events: (v-on)</h1>
    <p>v-on:eventName="action"</p>
    <p>instead of v-on we can use @ as a shortcut</p>
    <h2>example:</h2>
    <pre class="language-html">
      <code>  &lt;button v-on:click="add()"&gt;Add&lt;/button&gt;</code>
    </pre>

    <p>these functions can also take a parameter</p>
    <h2>example:</h2>
    <pre class="language-html">
    <code>  &lt;button v-on:click="add(5)"&gt;Add&lt;/button&gt;</code>
    </pre>

    <pre>
    <code class="language-javascript">  methods: {
    add(num) {
      this.counter+=num;
    }
  }</code>
  </pre>

    <p>we can also do some logic inside html but it's not the best practice</p>
    <h2>example:</h2>
    <pre>
    <code class="language-html">  &lt;button v-on:click="counter++"&gt;Add&lt;/button&gt;</code>
    </pre>


    <p>change a variable on an event</p>
    <h2>example:</h2>
    
    <pre>
    <code class="language-html">  &lt;input type="text" v-on:input="changeName"&gt;
  &lt;p&gt;Your Name: {{ name }}&lt;/p&gt;</code>
  </pre>

  <pre><code class="language-javascript">
  changeName(event) {
    this.name = event.target.value
  }</code>
</pre>

    <p class="note">Note: "event" is sent by default by the browser</p>

    <p>If we need to send another variable to the function, we need to include $event in the parameters list</p>
    <h2>example:</h2>
    <pre><code class="language-html">
  &lt;input type="text" v-on:input="changeName($event, Racovet)"&gt;
  &lt;p&gt;Your Name: {{ name }}&lt;/p&gt;</code>
    </pre>

  <pre><code class="language-javascript">
  changeName(event, lastName) {
    this.name = event.target.value + " " + lastName
  }</code>
  </pre>


    <h1>Event modifiers</h1>
    <p>Instead of using the traditional event.preventDefault(), Vue offers some modifiers of its own (.prevent)</p>
    <h2>example:</h2>
    <pre><code class="language-html">
  &lt;form v-on:submit.prevent="submitForm"&gt;
    &lt;input type="text"&gt;
    &lt;button&gt;Sign Up&lt;/button&gt;
  &lt;/form&gt;</code>
    </pre>

    <pre><code class="language-javascript">
  submitForm() {
    alert('Submitted');
  }</code>
  </pre>

    <ol>
        <li>
          <strong>.stop</strong>
          <ul>
            <li><strong>Description:</strong> Prevents further propagation of the current event.</li>
          </ul>
        </li>
        <li>
          <strong>.prevent</strong>
          <ul>
            <li><strong>Description:</strong> Prevents the default action of the event.</li>
          </ul>
        </li>
        <li>
          <strong>.capture</strong>
          <ul>
            <li><strong>Description:</strong> Makes the event listener run in the capture phase.</li>
          </ul>
        </li>
        <li>
          <strong>.self</strong>
          <ul>
            <li><strong>Description:</strong> Ensures the event is triggered only if the event target is the element itself.</li>
          </ul>
        </li>
        <li>
          <strong>.once</strong>
          <ul>
            <li><strong>Description:</strong> Ensures the event listener is invoked at most once.</li>
          </ul>
        </li>
        <li>
          <strong>.passive</strong>
          <ul>
            <li><strong>Description:</strong> Indicates that the event listener will never call preventDefault(). Useful for performance optimization in scroll events.</li>
          </ul>
        </li>
        <li>
          <strong>.native</strong> (Vue 2 only)
          <ul>
            <li><strong>Description:</strong> Allows listening to native DOM events on child components.</li>
          </ul>
        </li>
        <li>
          <strong>.exact</strong>
          <ul>
            <li><strong>Description:</strong> Ensures the event is triggered only if the exact modifier keys are pressed.</li>
          </ul>
        </li>
        <li>
          <strong>Modifier Key Combinations</strong>
          <ul>
            <li><strong>Description:</strong> Requires specific keys to be pressed (e.g., .ctrl, .alt, .shift, .meta).</li>
          </ul>
        </li>
        <li>
          <strong>Key Event Modifiers</strong>
          <ul>
            <li><strong>Description:</strong> Used to listen for specific key presses (e.g., .enter>, .tab, .delete, .esc, etc.).</li>
          </ul>
        </li>
        <li>
          <strong>Chaining Modifiers</strong>
          <ul>
            <li><strong>Description:</strong> Modifiers can be chained for more precise control.</li>
          </ul>
        </li>
    </ol>

    <h2>example:</h2>
    <pre><code class="language-html">
  &lt;input type="text" v-on:input="changeName($event, 'Racovet')" v-on:keyup.enter="confirmInput()"&gt;</code>
    </pre>

  <pre><code class="language-javascript">
  confirmInput() {
    this.confirmedName = this.name;
  },</code>
  </pre>
    

    <h2>v-model or the two-way binding</h2>
    <p>instead of using the v-bind:value in pair with the v-on:click</p>
    <h2>example:</h2>
    <pre><code class="language-html">
  &lt;input type="text" v-bind:value="name" v-on:input="setName"&gt;
  &lt;p&gt;Your Name: {{ name }}&lt;/p&gt;</code>
    </pre>
    <pre><code class="language-javascript">
  setName(event) {
    this.name = event.target.value;
  },</code>
  </pre>
    
    <p>we can just use v-model which does the same as the code above</p>
    <h2>example:</h2>
    <pre><code class="language-html">
  &lt;input type="text" v-model="name"&gt;
  &lt;p&gt;Your Name: {{ name }}&lt;/p&gt;</code>
    </pre>
    
    

    <h1>Computed properties</h1>
    <p>If we call a method to display a variable like this &lt;p&gt;{{ updatedName() }}&lt;/p&gt;, vue will call this method everytime there are any changes on the page because it doesn't know the dependencies of this method.
    This is why we use computed methods for displaying some changed variables since these will be executed only when their dependencies(variables) are changed.
    </p>

    <h2>example: (@keyup is just to make sure we display the updated name only when confirmed. Not really part of the example here)</h2>

    <pre><code class="language-html">
  &lt;input type="text" v-model="name" @keyup.enter="confirmName"&gt;
  &lt;p&gt;Your Name: {{ changedName }}&lt;/p&gt;</code>
    </pre>
    <pre><code class="language-javascript">
  computed: {
    changedName() {
      if (this.confirmedName != "")
        return this.confirmedName + " " + "Racovet";
      else 
        return "";
    }
  },
  methods: {
    ...
    confirmName() {
      this.confirmedName = this.name;
    }
  }</code>
  </pre>
    

    <h1>Watchers</h1>
    <p>watch methods are used to change something or perform an action when a variable's value has changed. This is useful for http requests, alerts etc. A watch method is named as the variable it's supposed to watch after</p>

    <h2>example:</h2>
    <pre><code class="language-javascript">
  watch: {
    counter(value) {
      if (value &gt; 50) {
        this.counter = 0;
        window.alert("The counter has been set to 0");
      }
    }
  },</code>
    </pre>
    

    <h1>Methods vs Computed vs Watch</h1>
    <img src="https://raw.githubusercontent.com/Laur2003/vue-udemy/main/notes/images/image1.png" alt="">

    <h1>Conditionally adding classes to elements</h1>
    <p>To add a class to an element we will use :class binding</p>
    <h2>example:</h2>
    <pre><code class="language-html">
  &lt;div class="demo" :class="{active: boxSelected}" @click="clickOnBox"&gt;&lt;/div&gt;</code>
    </pre>
    <pre><code class="language-javascript">
  data() {
    return {
      boxSelected: false
    }
  },
  methods: {
    clickOnBox() {
      this.boxSelected = !this.boxSelected;
    }
  }</code>
  </pre>
    

    <p>we can also use computed methods to change the classes if the logic is a bit more complicated or if we have more classes to add/have</p>
    <h2>example:</h2>
    <pre><code class="language-html">
  &lt;div class="demo" :class="boxClasses" @click="clickOnBox"&gt;&lt;/div&gt;</code>
    </pre>

    <pre><code class="language-javascript">
  data() {
    return {
      boxSelected: false
    }
  },
  methods: {
    clickOnBox() {
      this.boxSelected = !this.boxSelected;
    }
  },
  computed: {
    boxClasses() {
      return { active: this.boxSelected };
    }
  }</code>
    </pre>
    

    <p>there is also the possibility to add classes using the array syntax. We can combine conditional and static classes in such arrays</p>
    <h2>example:</h2>

    <pre><code class="language-html">
  &lt;div :class="['demo', boxClasses]" @click="clickOnBox"&gt;&lt;/div&gt;</code>
    </pre>
    


    <h1>Conditional rendering/displaying</h1>
    <h2>v-if, v-else-if, v-else</h2>
    <p>to render content conditionally, we use v-if, v-else-if, v-else. This RENDERS the content which means if the condition is not true for any of these operators, the DOM will not populate with the respective content</p>

    <h2>example:</h2>
    <pre><code class="language-html">
  &lt;p v-if="goals.length == 0"&gt;No goals have been added yet&lt;/p&gt;
  &lt;ul v-else&gt;
    &lt;li&gt;Goals&lt;/li&gt;
  &lt;/ul&gt;</code>
    </pre>
    <pre><code class="language-javascript">
  data() {
    return { 
      goals: []
    };
  },</code>
  </pre>
    

    <h2>v-show</h2>
    <p>to render a piece of content in the DOM but just to hide it if needed, we can use v-show. Generally it's better to use conditional rendering instead of conditional hiding due to security reasons. However, if an element's visibility is being switched a lot and it's not impacting the security of the page, we will use v-show because of performance (rendering the same element multiple time is not the most optimal way to do thintgs)</p>


    <h1>Rendering lists of data</h1>
    <p>to render lists/arrays, we use v-for</p>
    <h2>example:</h2>
    <pre><code class="language-html">
  &lt;ul&gt;
    &lt;li v-for="goal in goals"&gt;{{ goal }}&lt;/li&gt;
  &lt;/ul&gt;</code>
    </pre>

    <pre><code class="language-javascript">
  data() {
    return { 
      goals: ['goal1', 'goal2']
    };
  }</code>
  </pre>
    
    <p class="note">Note: if we have an unique ID available, it's always a good idea to also include :key="id"</p>

    <p>we can also use indexes for the loop</p>
    <h2>example:</h2>
    <pre><code class="language-html">
  &lt;ul&gt;
    &lt;li v-for="(goal, index) in goals"&gt;{{ goal }}{{ index }}&lt;/li&gt;
  &lt;/ul&gt;</code>
    </pre>
  <pre><code class="language-javascript">
  data() {
    return { 
      goals: ['goal1', 'goal2']
    };
  },</code>
  </pre>
    

    <p>we can also loop through objects and display the key and the index</p>
    <h2>example:</h2>
    <pre><code class="language-html">
  &lt;ul v-else&gt;
    &lt;li v-for="(goal, key, index) in goalsObject"&gt;{{ key }}-{{ goal }}-{{ index }}&lt;/li&gt;
  &lt;/ul&gt;</code>
    </pre>
    <pre><code class="language-javascript">
  data() {
    return { 
      goalsObject: {
        name: "TestGoal",
        importance: "High"
      }
    };
  },</code>
  </pre>
    

    <p>to remove an item from a list we can use .splice()</p>
    <h2>example:</h2>
    <pre><code class="language-html">
  &lt;li
    v-for="(goal, index) in goals"
    @click="removeItem(index)"&gt;
    {{ goal }}{{ index }}
  &lt;/li&gt;</code>
  </pre>

    <pre><code class="language-javascript">
  removeItem(index) {
    this.goals.splice(index, 1);
  }</code>
  </pre>
    

    <h1>Vue: Behind the Scenes</h1>
    <h2>ref</h2>
    <p>instead of saving the input value on every keystroke, we can use a ref</p>
    <h2>example - without ref:</h2>
    <pre><code class="language-html">
  &lt;input type="text" @input="saveInput"&gt;
  &lt;button @click="setText"&gt;Set Text&lt;/button&gt;</code>
    </pre>
    <pre><code class="language-javascript">
  data() {
    return {
      currentUserInput: '',
      message: 'Vue is great!',
    };
  },
  methods: {
    saveInput(event) {
      this.currentUserInput = event.target.value;
    },
    setText() {
      this.message = this.currentUserInput;
    },
  },</code>
  </pre>
    

    <h2>example - with ref</h2>
    <pre><code class="language-html">
  &lt;input type="text" ref="userInput"&gt;
  &lt;button @click="setText"&gt;Set Text&lt;/button&gt;</code>
    </pre>
    <pre><code class="language-javascript">
  data() {
    return {
      message: 'Vue is great!'
    };
  },
  methods: {
    setText() {
      this.message = this.$refs.userInput.value;
    },
  },</code>
  </pre>
    


    <h2>Vue Instance Lifecycle</h2>
    <img src="https://raw.githubusercontent.com/Laur2003/vue-udemy/main/notes/images/image2.png" alt="">

    <h1>Components</h1>
    <p>essentially components are small vue apps which are used inside the main apps. We use components for reusability and because of performance.</p>
    <h2>example:</h2>
    <pre><code class="language-html">
  &lt;ul&gt;
    &lt;friend-contact&gt;&lt;/friend-contact&gt;
  &lt;/ul&gt;</code>
    </pre>
    <pre><code class="language-javascript">
  app.component('friend-contact', {
    template: \`
      &lt;li&gt;
        &lt;h2&gt;{{ friend.name }}&lt;/h2&gt;
        &lt;button @click="toggleDetails()"&gt;
          {{ detailsAreVisible ? 'Hide' : 'Show' }} Details
        &lt;/button&gt;
        &lt;ul v-if="detailsAreVisible"&gt;
          &lt;li&gt;&lt;strong&gt;Phone:&lt;/strong&gt; {{ friend.phone }}&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;Email:&lt;/strong&gt; {{ friend.email }}&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    \`,
    data() {
      return {
        detailsAreVisible: false,
        friend: {
          id: 'manuel',
          name: 'Manuel Lorenzo',
          phone: '01234 5678 991',
          email: 'manuel@localhost.com',
        },
      };
    },
    methods: {
      toggleDetails() {
        this.detailsAreVisible = !this.detailsAreVisible;
      },
    },
  });</code>
  </pre>
    

    <h1>Vue Cli</h1>
    <pre><code class="language-javascript">
  npm install -g @vue/cli

  vue create my-project

  sudo npm run serve</code>
    </pre>
    

    <h2>components</h2>
    <h2>example:</h2>
    <pre><code class="language-html">
  FriendContact.vue
  &lt;template&gt;
    &lt;li&gt;
      &lt;h2&gt;{{ friend.name }}&lt;/h2&gt;
      &lt;button @click="toggleDetails"&gt;{{detailsAreVisible ? 'Hide' : 'Show'}} Details&lt;/button&gt;
      &lt;ul v-if="detailsAreVisible"&gt;
        &lt;li&gt;&lt;strong&gt;Phone:&lt;/strong&gt; {{ friend.phone }}&lt;/li&gt;
        &lt;li&gt;&lt;strong&gt;Email:&lt;/strong&gt; {{ friend.email }}&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/template&gt;</code>
    </pre>

    <pre><code class="language-javascript">
  //main.js
  import FriendContact from './components/FriendContact.vue';
  app.component('friend-contact', FriendContact);

  App.vue
  &lt;friend-contact&gt;&lt;/friend-contact&gt;</code>
  </pre>
    

    <h2>props - passing data from parent to child element</h2>
    <h2>example: </h2>
    <pre><code class="language-html">
  parent element
  &lt;friend-contact
    name="Laur Racovet"
    phone-number="01234 78992"
    email-address="laur@example.com"
  &gt;&lt;/friend-contact&gt;

  child element
  &lt;li&gt;&lt;strong&gt;Phone:&lt;/strong&gt; {{ phoneNumber }}&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Email:&lt;/strong&gt; {{ emailAddress }}&lt;/li&gt;</code>
    </pre>
    <pre><code class="language-javascript">
  export default {
    props: [
      'name',
      'phoneNumber',
      'emailAddress'
    ]
    ...
  }</code>
  </pre>
    

    <h2>unidirectional data flow</h2>
    <p>props should't be mutated inside the child element. If we need to change a prop inside a child element, we just have to assign this prop to a temp variable</p>

    <h2>prop validation</h2>
    <h2>example:</h2>

    <pre class="language-javascript"><code>
  props: {
    name: {
      type: String,
      required: true,
      default: 'Friend'
    },
    phoneNumber: String,
    emailAddress: String,
    isFavourite: {
      type: String,
      required: false,
      default: '0',
      validator: function(value) {
        return value === '1' || value === '0';
      }
    }
  },</code>
    </pre>
    
    
    <h2>supported prop values:</h2>
    <ul>
      <li>String</li>
      <li>Number</li>
      <li>Boolean</li>
      <li>Array</li>
      <li>Object</li>
      <li>Date</li>
      <li>Function</li>
      <li>Symbol</li>
    </ul>

    <p>for loop with components</p>
    <h2>example:</h2>

    <pre><code class="language-html">
  &lt;friend-contact
    v-for="friend in friends"  
    :key="friend.id"
    :name="friend.name"
    :phone-number="friend.phone"
    :email-address="friend.email"
    :is-favourite="friend.isFavourite"
  /&gt;</code>
    </pre>
    <pre><code class="language-javascript">
  // Parent component
  data() {
    return {
      friends: [
        {
          id: 0,
          name: 'Laur Racovet',
          phone: '123 456 789',
          email: 'laur@example.com',
          isFavourite: true
        },
        {
          id: 1,
          name: 'Ryan Gosling',
          phone: '123 456 788',
          email: 'ryan@example.com',
          isFavourite: false
        }
      ]
    }
  }</code>
  </pre>
  
  <pre><code class="language-javascript">
  // Child component
  props: {
    id: Number,
    name: {
      type: String,
      required: true,
      default: 'Friend'
    },
    phoneNumber: String,
    emailAddress: String,
    isFavourite: {
      type: Boolean,
      required: false,
      default: false
    }
  }</code>
</pre>


<p>sending events/info from the child element to the parent element</p>
<h2>example:</h2>

<p>parent component</p>
<pre><code class="language-html">
  &lt;friend-contact
    v-for="friend in friends"  
    :key="friend.id"
    :id="friend.id"
    :name="friend.name"
    :phone-number="friend.phone"
    :email-address="friend.email"
    :is-favourite="friend.isFavourite"
    @toggle-favourite="toggleFavourite" // this line
  &gt;&lt;/friend-contact&gt;
</code>
</pre>

<pre><code class="language-javascript">
  methods: {
    toggleFavourite(id) {
      this.friends[id].isFavourite = !this.friends[id].isFavourite;
    }
  }
</code>
</pre>

<p>child component</p>
<pre><code class="language-html">
  &lt;button @click="toggleFavourite"&gt;{{ isFavouriteText }}&lt;/button&gt;
</code>
</pre>

<pre><code class="language-javascript">
  toggleFavourite() {
    this.$emit('toggle-favourite', this.id);
  }
</code>
</pre>
<p>it's also recommended to define the events the child component will send</p>
<h2>example:</h2>

<pre><code class="language-javascript">
  export default {
    ...
    emits: ['toggle-favourite'],
  
    // When we want to make some validation
    emits: {
      'toggle-favourite': function(id) {
        if (id) {
          return true;
        } else {
          console.warn("Id is missing");
          return false;
        }
      }
    },
    ...
  }
</code>
</pre>

<h2>provide and inject - a way of avoiding pass-through components</h2>
<p>there will be use cases when we will need to pass data from an ancestor component to a child component and to avoid using props on every parent-child relationship,
  we can set a provide method which will be on the ancestor element and an inject method on the child component
</p>

<h2>example:</h2>
<pre><code class="language-javascript">
  // ancestor component
  export default {
    provide() {
      return {
        username: 'Jane',
        age: 28
      }
    }
  }


  // child component
  export default {
    inject: ['username', 'age']
  }
</code>
</pre>

<h2>global vs local components:</h2>
<p>currently we are defining components globally in main.js like this:</p>
<pre><code class="language-javascript">
  import BaseBadge from './components/BaseBadge.vue';
  import BadgeList from './components/BadgeList.vue';
  import UserInfo from './components/UserInfo.vue';

  const app = createApp(App);

  app.component('base-badge', BaseBadge);
  app.component('badge-list', BadgeList);
  app.component('user-info', UserInfo);
</code>
</pre>

<p>this approach is not wrong but it makes the components global which means those will be called and stored in browser's memory
  on page load which will make the app slower if there are multiple components. This is how we can import components locally
</p>
<pre><code class="language-javascript">
  import TheHeader from './components/TheHeader.vue';

  export default {
    components: {
      TheHeader
    },
  ...
</code>
</pre>

<pre><code class="language-html">
  &lt;the-header&gt;&lt;/the-header&gt;
</code>
</pre>

<p>the-header is generated by default by vue. No need to specify a name if we just want to use kebab case</p>

<h2>styles scoping</h2>
<p>the styles from the components are actually global. If we need the styles to apply only on this component, we need to scope these</p>
<h2>example:</h2>
<pre><code class="language-html">
  &lt;style scoped&gt;
    header {
      width: 100%;
      height: 5rem;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #14005e;
    }
  
    header h1 {
      color: white;
      margin: 0;
    }
  &lt;/style&gt;
</code>
</pre>

<h1>Introducing slots</h1>
<p>Just as we can send props to a component's data, we also can send html content for the template. This is useful if we want 
  to wrap some dynamic content in a custom component with it's own styles.
</p>
<h2>example:</h2>
<pre><code class="language-html">
  // BaseCard.vue - wrapper element
  &lt;template&gt;
    &lt;div&gt;
      &lt;slot&gt;&lt;/slot&gt;
    &lt;/div&gt;
  &lt;/template&gt;

  &lt;script&gt;
  &lt;/script&gt;

  &lt;style scoped&gt;
    div {
      margin: 2rem auto;
      max-width: 30rem;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.26);
      padding: 1rem;
    }
  &lt;/style&gt;

  // UserInfo.vue
  &lt;base-card&gt;
    &lt;header&gt;
      &lt;h3&gt;{{ fullName }}&lt;/h3&gt;
      &lt;base-badge :type="role" :caption="role.toUpperCase()"&gt;&lt;/base-badge&gt;
    &lt;/header&gt;
    &lt;p&gt;{{ infoText }}&lt;/p&gt;
  &lt;/base-card&gt;
</code>
</pre>

<p>we can also name slots if we want to use more than one per component</p>

<h2>example:</h2>
<pre><code class="language-html">
  // BaseCard.vue - wrapper element
  &lt;template&gt;
    &lt;div&gt;
        &lt;header&gt;
            &lt;slot name="header"&gt;&lt;/slot&gt;
        &lt;/header&gt;
        &lt;slot name="body-content"&gt;&lt;/slot&gt;
    &lt;/div&gt;
  &lt;/template&gt;

  // UserInfo.vue
  &lt;base-card&gt;
    &lt;template v-slot:header&gt;
      &lt;h3&gt;{{ fullName }}&lt;/h3&gt;
      &lt;base-badge :type="role" :caption="role.toUpperCase()"&gt;&lt;/base-badge&gt;
    &lt;/template&gt;
    &lt;template v-slot:body-content&gt;
      &lt;p&gt;{{ infoText }}&lt;/p&gt;
    &lt;/template&gt;
  &lt;/base-card&gt;
</code>
</pre>

<p>We can have some default content inside of a slot if we just enter it where the slot will be called.
  Then, if we call the slot and give no additional content, it will render the default.
</p>

<p>We can also conditionally render content depending on what info we have for a slot</p>
<pre><code class="language-javascript">
  v-if="$slots.slot_name"
</code>
</pre>

<h2>dynamic components</h2>
<p>instead of using v-if if we want to render different components based on a variable/scenario, we can use it like this</p>
<pre><code class="language-html">
  &lt;button @click="setSelectedComponents('active-goals')"&gt;Active Goals&lt;/button&gt;
  &lt;button @click="setSelectedComponents('manage-goals')"&gt;Manage Goals&lt;/button&gt;
  &lt;!-- &lt;active-goals v-if="selectedComponent === 'active-goals'"&gt;&lt;/active-goals&gt;
  &lt;manage-goals v-if="selectedComponent === 'manage-goals'"&gt;&lt;/manage-goals&gt; --&gt;
  &lt;component :is="selectedComponent"&gt;&lt;/component&gt;
</code>
</pre>

<p>this approach is good but it removes the component from the DOM which means that if the user entered some data and then switched to another component,
  the progress will be lost. For this we have a solution.
</p>
<pre><code class="language-html">
  &lt;keep-alive&gt;
    &lt;component :is="selectedComponent"&gt;&lt;/component&gt;
  &lt;/keep-alive&gt;
</code>
</pre>

<h2>
  teleport
</h2>
<p>sometimes we will need to call components from one place but have them rendered in the DOM in another place. This might be useful
  when we need to display a dialog
</p>

<h2>example:</h2>
<pre><code class="language-html">
  &lt;teleport to="body"&gt;
    &lt;error-alert v-if="inputIsInvalid"&gt;
        &lt;h1&gt;Input is invalid&lt;/h1&gt;
        &lt;button @click="hideError"&gt;Okay&lt;/button&gt;
    &lt;/error-alert&gt;
  &lt;/teleport&gt;
</code>
</pre>

<h2>components summary</h2>
  <img src="images/image3.png" alt="">
</body>
</html>
